"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

var _objectWithoutProperties = function (obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; };

var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

var mixin = _interopRequire(require("smart-mixin"));

var cache = {},
    BaseClass;

module.exports = function (registry) {
  var _ref = arguments[1] === undefined ? {} : arguments[1];

  var _ref$ruleset = _ref.ruleset;
  var ruleset = _ref$ruleset === undefined ? {} : _ref$ruleset;
  var _ref$naming = _ref.naming;
  var naming = _ref$naming === undefined ? false : _ref$naming;

  ruleset = Object.keys(ruleset).reduce(function (mixinRuleset, classRule) {
    mixinRuleset[classRule] = Object.keys(ruleset[classRule]).reduce(function (mixinClassRuleset, methodRule) {
      mixinClassRuleset[methodRule] = mixin[ruleset[classRule][methodRule]];

      return mixinClassRuleset;
    }, {});

    return mixinRuleset;
  }, {});

  Object.assign(ruleset, {
    ReactComponent: {
      componentWillMount: mixin.MANY,
      componentDidMount: mixin.MANY,
      componentWillReceiveProps: mixin.MANY,
      shouldComponentUpdate: mixin.ONCE,
      componentWillUpdate: mixin.MANY,
      componentDidUpdate: mixin.MANY,
      componentWillUnmount: mixin.MANY,

      getInitialState: mixin.MANY_MERGED,
      getDefaultProps: mixin.MANY_MERGED
    }
  });

  return {
    on: function on(baseclass) {
      BaseClass = baseclass;
    },

    using: function using(descriptor) {
      var traits = descriptor[0].split(" "),
          traitsClassName = "" + BaseClass.name + "_with_" + traits.join("_and_");

      if (cache[traitsClassName]) {
        return cache[traitsClassName];
      } else {
        var _ret = (function () {
          var TraitsClass = (function (BaseClass) {
            function TraitsClass() {
              var _this3 = this;

              for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }

              _classCallCheck(this, TraitsClass);

              BaseClass.call.apply(BaseClass, [this].concat(args));

              traits.map(function (x) {
                var _registry$x = registry[x];
                var constructor = _registry$x.constructor;

                var methods = _objectWithoutProperties(_registry$x, ["constructor"]);

                "constructor" === constructor.name && constructor.call(_this3);

                mixin(ruleset[BaseClass.name] || {})(_this3.constructor.prototype, methods);
              });
            }

            _inherits(TraitsClass, BaseClass);

            return TraitsClass;
          })(BaseClass);

          naming && eval("TraitsClass = (function (BaseClass) {\n                          " + TraitsClass.toString().split("TraitsClass").join(traitsClassName) + "\n                          _inherits(" + traitsClassName + ", BaseClass);\n\n                          return " + traitsClassName + ";\n                        })(BaseClass);");

          return {
            v: cache[traitsClassName] = TraitsClass
          };
        })();

        if (typeof _ret === "object") {
          return _ret.v;
        }
      }
    }
  };
};